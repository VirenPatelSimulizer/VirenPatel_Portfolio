<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Viren Patel - Technology enthusiast, podcast host, and simulation developer. Explore my portfolio of projects and listen to Decoded with Viren.">
  <title>Charged Particle Simulation - Viren Patel</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/css/styles.css">
  <style>
    /* Simulation Container */
    .simulation-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 80px);
      margin-top: 70px;
      display: flex;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      overflow: hidden;
    }

    /* Sidebar Styles */
    .simulation-sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 320px;
      max-width: 320px;
      height: 100%;
      max-height: 100vh;
      background: rgba(20, 20, 40, 0.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      padding: 20px;
      box-sizing: border-box;
      overflow-y: hidden;
      overflow-x: hidden;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
      color: #e0e0e0;
    }

    .simulation-sidebar.collapsed {
      transform: translateX(-100%);
    }

    .sidebar-toggle {
      position: fixed;
      left: 0;
      top: 20px;
      width: 40px;
      height: 40px;
      background: rgba(20, 20, 40, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: none;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 101;
    }

    .simulation-sidebar:not(.collapsed) .sidebar-toggle {
      left: 320px;
    }

    .simulation-sidebar.collapsed .sidebar-toggle {
      left: 0;
    }

    .sidebar-toggle:hover {
      background: rgba(30, 30, 50, 0.95);
    }

    .sidebar-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
    }

    .sidebar-control-btn {
      position: fixed;
      left: 320px;
      top: 80px;
      width: 40px;
      height: 40px;
      background: rgba(74, 158, 255, 0.3);
      border: 1px solid rgba(74, 158, 255, 0.6);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4a9eff;
      font-size: 20px;
      font-weight: bold;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 150;
    }

    .sidebar-control-btn:hover {
      background: rgba(74, 158, 255, 0.5);
      border-color: #4a9eff;
      transform: scale(1.1);
    }

    .simulation-sidebar.collapsed ~ .simulation-canvas-wrapper .sidebar-control-btn {
      left: 20px;
      top: 80px;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #b0b0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-value {
      float: right;
      color: #4a9eff;
      font-weight: 600;
    }

    .control-input {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .control-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .control-input::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    .control-select {
      width: 100%;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      outline: none;
    }

    .control-select option {
      background: #1a1a2e;
      color: #e0e0e0;
    }

    .delay-group {
      margin-top: 10px;
      padding: 10px;
      background: rgba(74, 158, 255, 0.1);
      border-left: 3px solid #4a9eff;
      border-radius: 4px;
      display: none;
    }

    .delay-group.visible {
      display: block;
    }

    /* Canvas Styles */
    .simulation-canvas-wrapper {
      flex: 1;
      position: relative;
    }

    #simulationCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    /* Back Button */
    .back-button {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #e0e0e0;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      z-index: 150;
    }

    .back-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateX(-3px);
      color: #4a9eff;
    }

    .back-arrow {
      font-size: 18px;
      transition: transform 0.3s;
    }

    .back-button:hover .back-arrow {
      transform: translateX(-3px);
    }

    /* Overlay Controls */
    .simulation-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      gap: 20px;
      z-index: 50;
    }

    .simulation-overlay.active {
      display: flex;
    }

    .overlay-button {
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .overlay-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(74, 158, 255, 0.3);
    }

    .overlay-button.play {
      background: rgba(74, 158, 255, 0.2);
      border-color: #4a9eff;
    }

    .overlay-button.reset {
      background: rgba(255, 74, 74, 0.2);
      border-color: #ff4a4a;
    }

    /* Stats Display */
    .simulation-stats {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #e0e0e0;
      font-size: 12px;
      line-height: 1.6;
      z-index: 50;
      display: flex;
      gap: 20px;
    }

    .stat-item {
      display: flex;
      gap: 8px;
    }

    .stat-value {
      color: #4a9eff;
      font-weight: 600;
    }

    .stat-positive {
      color: #00d4ff;
    }

    .stat-negative {
      color: #ff6b35;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .simulation-sidebar {
        width: 280px;
      }

      .simulation-sidebar.collapsed {
        transform: translateX(-280px);
      }

      .overlay-button {
        padding: 12px 30px;
        font-size: 14px;
      }

      .back-text {
        display: none;
      }

      .simulation-stats {
        font-size: 10px;
        padding: 10px 12px;
        gap: 12px;
        flex-wrap: wrap;
      }
    }

    @media (max-width: 480px) {
      .simulation-sidebar {
        width: 240px;
      }

      .simulation-sidebar.collapsed {
        transform: translateX(-240px);
      }
    }
  </style>
</head>
<body>
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
 
  <!-- Navbar -->
  <header>
    <nav>
      <div class="logo">
        <a href="index.html">Viren Patel</a>
      </div>
      <div class="logo">
        <a>Charged Particle Simulation</a>
      </div>
      <ul class="nav-links">
        <li><a href="#hero">Home</a></li>
        <li><a href="portfolio.html">Portfolio</a></li>
        <li><a href="simulations/index.html">Simulations</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
  </header>
 
  <!--  Add Simulation below here  -->
  <div class="simulation-container">
    <!-- Sidebar -->
    <div class="simulation-sidebar" id="simulationSidebar">
      <div class="sidebar-toggle" id="sidebarToggle">&#9776;</div>
      <div class="sidebar-title">Simulation Controls</div>
      
      <div class="control-group">
        <label class="control-label">
          Wall Mode
        </label>
        <select class="control-select" id="wallMode">
          <option value="solid">Solid Walls (Bounce)</option>
          <option value="wrap">Wrap-Around (Continuous)</option>
        </select>
      </div>

      <div class="control-group">
        <label class="control-label">
          Spawn Mode
        </label>
        <select class="control-select" id="spawnMode">
          <option value="both">Both Together</option>
          <option value="positiveFirst">Positive First</option>
          <option value="negativeFirst">Negative First</option>
        </select>
      </div>

      <div class="control-group delay-group" id="delayGroup">
        <label class="control-label">
          Spawn Delay (seconds)
          <span class="control-value" id="spawnDelayValue">10.0</span>
        </label>
        <input type="range" class="control-input" id="spawnDelay" min="0" max="60" step="0.5" value="10">
      </div>

      <div class="control-group">
        <label class="control-label">
          Positive Count
          <span class="control-value" id="positiveCountValue">50</span>
        </label>
        <input type="range" class="control-input" id="positiveCount" min="1" max="1000" value="50">
      </div>

      <div class="control-group">
        <label class="control-label">
          Negative Count
          <span class="control-value" id="negativeCountValue">50</span>
        </label>
        <input type="range" class="control-input" id="negativeCount" min="1" max="1000" value="50">
      </div>

      <div class="control-group">
        <label class="control-label">
          Speed
          <span class="control-value" id="speedValue">1.0</span>
        </label>
        <input type="range" class="control-input" id="speed" min="0" max="5" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Charge Range
          <span class="control-value" id="chargeRangeValue">10</span>
        </label>
        <input type="range" class="control-input" id="chargeRange" min="1" max="10" step="1" value="10">
      </div>

      <div class="control-group">
        <label class="control-label">
          Radius Scale
          <span class="control-value" id="radiusScaleValue">1.0</span>
        </label>
        <input type="range" class="control-input" id="radiusScale" min="0.5" max="3" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Bond Length Factor
          <span class="control-value" id="bondLengthFactorValue">1.0</span>
        </label>
        <input type="range" class="control-input" id="bondLengthFactor" min="0.5" max="3" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Force +/+ (attract/repel)
          <span class="control-value" id="force_ppValue">0.5</span>
        </label>
        <input type="range" class="control-input" id="force_pp" min="-1" max="1" step="0.01" value="0.5">
      </div>

      <div class="control-group">
        <label class="control-label">
          Force +/- (attract/repel)
          <span class="control-value" id="force_pnValue">-0.3</span>
        </label>
        <input type="range" class="control-input" id="force_pn" min="-1" max="1" step="0.01" value="-0.3">
      </div>

      <div class="control-group">
        <label class="control-label">
          Force -/- (attract/repel)
          <span class="control-value" id="force_nnValue">0.5</span>
        </label>
        <input type="range" class="control-input" id="force_nn" min="-1" max="1" step="0.01" value="0.5">
      </div>

      <div class="control-group">
        <label class="control-label">
          Time Step (dt)
          <span class="control-value" id="dtValue">0.016</span>
        </label>
        <input type="range" class="control-input" id="dt" min="0.001" max="0.05" step="0.001" value="0.016">
      </div>
    </div>

    <!-- Canvas Wrapper -->
    <div class="simulation-canvas-wrapper">
      <canvas id="simulationCanvas"></canvas>

      <!-- Sidebar Control Button -->
      <div class="sidebar-control-btn" id="sidebarControlBtn">←</div>

      <!-- Back Button -->
      <a href="../index.html" class="back-button" id="backButton">
        <span class="back-arrow">←</span>
        <span class="back-text">Back to Simulations</span>
      </a>

      <!-- Stats Display -->
      <div class="simulation-stats" id="statsDisplay">
        <div class="stat-item">
          <span>FPS:</span>
          <span class="stat-value" id="fpsValue">60</span>
        </div>
        <div class="stat-item">
          <span class="stat-positive">Positive:</span>
          <span class="stat-value stat-positive" id="positiveParticles">50</span>
        </div>
        <div class="stat-item">
          <span class="stat-negative">Negative:</span>
          <span class="stat-value stat-negative" id="negativeParticles">50</span>
        </div>
        <div class="stat-item">
          <span>Total Energy:</span>
          <span class="stat-value" id="totalEnergy">0</span>
        </div>
      </div>

      <!-- Overlay Controls -->
      <div class="simulation-overlay active" id="simulationOverlay">
        <button class="overlay-button play" id="playButton">Play</button>
        <button class="overlay-button reset" id="resetButton">Reset</button>
      </div>
    </div>
  </div>
  <!--  Add Simulation End here  -->
 
  <!-- Footer -->
  <footer>
    <div class="footer-content">
      <p>&copy; 2025 Viren Patel. All rights reserved.</p>
      <div class="social-links">
        <a href="mailto:virenp.jobs@gmail.com">Email</a>
        <a href="https://www.linkedin.com/in/-virenpatel" target="_blank">LinkedIn</a>
        <a href="https://calendly.com/virenp-jobs/new-connection-linkedin" target="_blank">Schedule Call</a>
      </div>
    </div>
  </footer>

  <script>
    /**
     * Charged Particle Physics Engine
     * Semi-implicit Euler integration with momentum conservation
     */

    const params = {
      positiveCount: 50,
      negativeCount: 50,
      speed: 1.0,
      chargeRange: 10,
      radiusScale: 1.0,
      bondLengthFactor: 1.0,
      force_pp: 0.5,
      force_pn: -0.3,
      force_nn: 0.5,
      dt: 0.016,
      spawnMode: 'both',
      spawnDelay: 10.0,
      wallMode: 'solid'
    };

    const eps = 1e-3;
    const maxForce = 10;
    const k_spring = 0.5;
    const damping = 0.95;

    class Particle {
      constructor(x, y, chargeSign, speed) {
        this.pos = {x, y};
        this.vel = {x: 0, y: 0};
        this.force = {x: 0, y: 0};

        const chargeVal = Math.random() * params.chargeRange;
        this.charge = Math.max(-10, Math.min(10, chargeSign * (1 + chargeVal)));
        this.mass = Math.max(1, Math.abs(this.charge));
        this.radius = params.radiusScale * Math.sqrt(Math.max(1, Math.abs(this.charge)));

        const angle = Math.random() * Math.PI * 2;
        this.vel.x = Math.cos(angle) * speed * 100;
        this.vel.y = Math.sin(angle) * speed * 100;

        this.color = this.charge > 0 ? {r: 0, g: 212, b: 255} : {r: 255, g: 107, b: 53};
      }

      getKineticEnergy() {
        return 0.5 * this.mass * (this.vel.x * this.vel.x + this.vel.y * this.vel.y);
      }

      handleBoundaries(width, height) {
        if (params.wallMode === 'solid') {
          if (this.pos.x - this.radius < 0) {
            this.pos.x = this.radius;
            this.vel.x = -this.vel.x;
          } else if (this.pos.x + this.radius > width) {
            this.pos.x = width - this.radius;
            this.vel.x = -this.vel.x;
          }
          if (this.pos.y - this.radius < 0) {
            this.pos.y = this.radius;
            this.vel.y = -this.vel.y;
          } else if (this.pos.y + this.radius > height) {
            this.pos.y = height - this.radius;
            this.vel.y = -this.vel.y;
          }
        } else if (params.wallMode === 'wrap') {
          if (this.pos.x < 0) this.pos.x += width;
          else if (this.pos.x > width) this.pos.x -= width;
          if (this.pos.y < 0) this.pos.y += height;
          else if (this.pos.y > height) this.pos.y -= height;
        }
      }

      draw(ctx, bonds) {
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.6)`;
      }
    }

    let particles = [];
    let bonds = [];

    function getInteractionMultiplier(qi, qj) {
      if (qi > 0 && qj > 0) return params.force_pp;
      if (qi < 0 && qj < 0) return params.force_nn;
      return params.force_pn;
    }

    function initParticles(countP, countN, speed, canvas) {
      particles = [];
      bonds = [];
      for (let i = 0; i < countP; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        particles.push(new Particle(x, y, 1, speed));
      }
      for (let i = 0; i < countN; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        particles.push(new Particle(x, y, -1, speed));
      }
    }

    function computeForces() {
      for (let p of particles) {
        p.force.x = 0;
        p.force.y = 0;
      }

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const pi = particles[i];
          const pj = particles[j];
          const rx = pj.pos.x - pi.pos.x;
          const ry = pj.pos.y - pi.pos.y;
          const d = Math.max(Math.sqrt(rx * rx + ry * ry), eps);
          const k = getInteractionMultiplier(pi.charge, pj.charge);
          const forceMag = Math.max(-maxForce, Math.min(maxForce, k * (pi.charge * pj.charge) / (d * d)));
          const dirX = rx / d;
          const dirY = ry / d;
          const fx = dirX * forceMag;
          const fy = dirY * forceMag;

          pi.force.x += fx;
          pi.force.y += fy;
          pj.force.x -= fx;
          pj.force.y -= fy;
        }
      }

      for (let bond of bonds) {
        const pi = particles[bond.i];
        const pj = particles[bond.j];
        const rx = pj.pos.x - pi.pos.x;
        const ry = pj.pos.y - pi.pos.y;
        const d = Math.max(Math.sqrt(rx * rx + ry * ry), eps);
        const displacement = d - bond.restLength;
        const springForce = -bond.k_spring * displacement;
        const dampingForce = -bond.damping * ((pj.vel.x - pi.vel.x) * rx + (pj.vel.y - pi.vel.y) * ry) / d;
        const totalForce = springForce + dampingForce;
        const dirX = rx / d;
        const dirY = ry / d;
        const fx = dirX * totalForce;
        const fy = dirY * totalForce;

        pi.force.x += fx;
        pi.force.y += fy;
        pj.force.x -= fx;
        pj.force.y -= fy;
      }
    }

    function integrate(dt) {
      for (let p of particles) {
        p.vel.x += (p.force.x / p.mass) * dt;
        p.vel.y += (p.force.y / p.mass) * dt;
        p.pos.x += p.vel.x * dt;
        p.pos.y += p.vel.y * dt;
      }
    }

    function resolveOverlaps() {
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const pi = particles[i];
          const pj = particles[j];
          const rx = pj.pos.x - pi.pos.x;
          const ry = pj.pos.y - pi.pos.y;
          const d = Math.sqrt(rx * rx + ry * ry);
          const minDist = pi.radius + pj.radius;

          if (d < minDist && d > eps) {
            const nx = rx / d;
            const ny = ry / d;
            const overlap = minDist - d;
            pi.pos.x -= nx * overlap * 0.5;
            pi.pos.y -= ny * overlap * 0.5;
            pj.pos.x += nx * overlap * 0.5;
            pj.pos.y += ny * overlap * 0.5;

            const dvx = pi.vel.x - pj.vel.x;
            const dvy = pi.vel.y - pj.vel.y;
            const dvn = dvx * nx + dvy * ny;

            if (dvn < 0) {
              const impulse = (2 * dvn) / (pi.mass + pj.mass);
              pi.vel.x -= impulse * pj.mass * nx;
              pi.vel.y -= impulse * pj.mass * ny;
              pj.vel.x += impulse * pi.mass * nx;
              pj.vel.y += impulse * pi.mass * ny;
            }
          }
        }
      }
    }

    function updateBonds() {
      bonds = bonds.filter(bond => {
        const pi = particles[bond.i];
        const pj = particles[bond.j];
        const rx = pj.pos.x - pi.pos.x;
        const ry = pj.pos.y - pi.pos.y;
        const d = Math.sqrt(rx * rx + ry * ry);
        return d <= bond.restLength * 1.5;
      });

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const pi = particles[i];
          const pj = particles[j];
          const rx = pj.pos.x - pi.pos.x;
          const ry = pj.pos.y - pi.pos.y;
          const d = Math.sqrt(rx * rx + ry * ry);
          const k = getInteractionMultiplier(pi.charge, pj.charge);
          const bondRange = params.bondLengthFactor * (pi.radius + pj.radius) / 2;

          if (d <= bondRange && k * pi.charge * pj.charge < 0) {
            const exists = bonds.some(b => (b.i === i && b.j === j) || (b.i === j && b.j === i));
            if (!exists) {
              bonds.push({
                i, j,
                restLength: bondRange,
                k_spring: k_spring,
                damping: damping * 0.1
              });
            }
          }
        }
      }
    }

    function step(dt, canvas) {
      computeForces();
      integrate(dt);
      resolveOverlaps();
      for (let p of particles) {
        p.handleBoundaries(canvas.width, canvas.height);
      }
      updateBonds();
    }

    function setParams(newParams) {
      Object.assign(params, newParams);
    }

    function reset(canvas) {
      initParticles(params.positiveCount, params.negativeCount, params.speed, canvas);
    }

    const Simulation = {
      canvas: null,
      ctx: null,
      isPaused: true,
      lastTime: 0,
      fps: 60,
      frameCount: 0,
      fpsTime: 0,
      spawnTimer: 0,
      secondGroupSpawned: false,

      init(canvasElement, initialParams) {
        this.canvas = canvasElement;
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        Object.assign(params, initialParams);
        this.createParticles();
        this.lastTime = performance.now();
        this.animate();
      },

      resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      },

      createParticles() {
        this.spawnTimer = 0;
        this.secondGroupSpawned = false;

        if (params.spawnMode === 'both') {
          initParticles(params.positiveCount, params.negativeCount, params.speed, this.canvas);
          this.secondGroupSpawned = true;
        } else if (params.spawnMode === 'positiveFirst') {
          initParticles(params.positiveCount, 0, params.speed, this.canvas);
        } else if (params.spawnMode === 'negativeFirst') {
          initParticles(0, params.negativeCount, params.speed, this.canvas);
        }
      },

      checkDelayedSpawn(dt) {
        if (this.secondGroupSpawned) return;
        this.spawnTimer += dt;

        if (this.spawnTimer >= params.spawnDelay) {
          if (params.spawnMode === 'positiveFirst') {
            for (let i = 0; i < params.negativeCount; i++) {
              particles.push(new Particle(Math.random() * this.canvas.width, Math.random() * this.canvas.height, -1, params.speed));
            }
          } else if (params.spawnMode === 'negativeFirst') {
            for (let i = 0; i < params.positiveCount; i++) {
              particles.push(new Particle(Math.random() * this.canvas.width, Math.random() * this.canvas.height, 1, params.speed));
            }
          }
          this.secondGroupSpawned = true;
        }
      },

      animate() {
        requestAnimationFrame(() => this.animate());
        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;

        this.frameCount++;
        this.fpsTime += deltaTime;
        if (this.fpsTime >= 1) {
          this.fps = Math.round(this.frameCount / this.fpsTime);
          this.frameCount = 0;
          this.fpsTime = 0;
        }

        if (!this.isPaused) {
          this.update(deltaTime);
        }
        this.draw();
        this.updateStats();
      },

      update(dt) {
        dt = Math.min(dt, 0.033);
        this.checkDelayedSpawn(dt);
        step(params.dt, this.canvas);
      },

      draw() {
        this.ctx.fillStyle = 'rgba(10, 10, 10, 1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        for (let bond of bonds) {
          const pi = particles[bond.i];
          const pj = particles[bond.j];
          this.ctx.beginPath();
          this.ctx.moveTo(pi.pos.x, pi.pos.y);
          this.ctx.lineTo(pj.pos.x, pj.pos.y);
          this.ctx.strokeStyle = 'rgba(255, 255, 100, 0.5)';
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
        }

        for (const p of particles) {
          p.draw(this.ctx, bonds);
        }
        this.ctx.shadowBlur = 0;
      },

      updateStats() {
        document.getElementById('fpsValue').textContent = this.fps;
        let positiveCount = 0, negativeCount = 0, totalEnergy = 0;
        for (const p of particles) {
          if (p.charge > 0) positiveCount++;
          else negativeCount++;
          totalEnergy += p.getKineticEnergy();
        }
        document.getElementById('positiveParticles').textContent = positiveCount;
        document.getElementById('negativeParticles').textContent = negativeCount;
        document.getElementById('totalEnergy').textContent = Math.round(totalEnergy);
      },

      reset() {
        this.pause();
        this.createParticles();
        this.draw();
      },

      pause() {
        this.isPaused = true;
      },

      play() {
        this.isPaused = false;
        this.lastTime = performance.now();
      }
    };

    // UI Controller
    const UIController = {
      sidebar: null,
      overlay: null,
      playButton: null,
      resetButton: null,

      init() {
        this.sidebar = document.getElementById('simulationSidebar');
        this.overlay = document.getElementById('simulationOverlay');
        this.playButton = document.getElementById('playButton');
        this.resetButton = document.getElementById('resetButton');

        this.setupSidebarToggle();
        this.setupControls();
        this.setupOverlay();
        this.setupCanvas();
        this.showOverlay();
      },

      setupSidebarToggle() {
        const toggle = document.getElementById('sidebarToggle');
        const controlBtn = document.getElementById('sidebarControlBtn');

        const updateButtons = () => {
          const isCollapsed = this.sidebar.classList.contains('collapsed');
          toggle.textContent = isCollapsed ? '☰' : '✕';
          controlBtn.textContent = isCollapsed ? '→' : '←';
        };

        toggle.addEventListener('click', () => {
          this.sidebar.classList.toggle('collapsed');
          updateButtons();
        });

        controlBtn.addEventListener('click', () => {
          this.sidebar.classList.toggle('collapsed');
          updateButtons();
        });

        // Initialize button states
        updateButtons();
      },

      setupControls() {
        const wallModeSelect = document.getElementById('wallMode');
        wallModeSelect.addEventListener('change', (e) => {
          params.wallMode = e.target.value;
        });

        const spawnModeSelect = document.getElementById('spawnMode');
        const delayGroup = document.getElementById('delayGroup');
        spawnModeSelect.addEventListener('change', (e) => {
          params.spawnMode = e.target.value;
          if (params.spawnMode === 'both') {
            delayGroup.classList.remove('visible');
          } else {
            delayGroup.classList.add('visible');
          }
        });

        const spawnDelayInput = document.getElementById('spawnDelay');
        const spawnDelayValue = document.getElementById('spawnDelayValue');
        spawnDelayInput.addEventListener('input', (e) => {
          params.spawnDelay = parseFloat(e.target.value);
          spawnDelayValue.textContent = params.spawnDelay.toFixed(1);
        });

        const positiveCountInput = document.getElementById('positiveCount');
        const positiveCountValue = document.getElementById('positiveCountValue');
        positiveCountInput.addEventListener('input', (e) => {
          params.positiveCount = parseInt(e.target.value);
          positiveCountValue.textContent = params.positiveCount;
        });

        const negativeCountInput = document.getElementById('negativeCount');
        const negativeCountValue = document.getElementById('negativeCountValue');
        negativeCountInput.addEventListener('input', (e) => {
          params.negativeCount = parseInt(e.target.value);
          negativeCountValue.textContent = params.negativeCount;
        });

        const speedInput = document.getElementById('speed');
        const speedValue = document.getElementById('speedValue');
        speedInput.addEventListener('input', (e) => {
          params.speed = parseFloat(e.target.value);
          speedValue.textContent = params.speed.toFixed(1);
        });

        const chargeRangeInput = document.getElementById('chargeRange');
        const chargeRangeValue = document.getElementById('chargeRangeValue');
        chargeRangeInput.addEventListener('input', (e) => {
          params.chargeRange = parseInt(e.target.value);
          chargeRangeValue.textContent = params.chargeRange;
        });

        const radiusScaleInput = document.getElementById('radiusScale');
        const radiusScaleValue = document.getElementById('radiusScaleValue');
        radiusScaleInput.addEventListener('input', (e) => {
          params.radiusScale = parseFloat(e.target.value);
          radiusScaleValue.textContent = params.radiusScale.toFixed(1);
        });

        const bondLengthFactorInput = document.getElementById('bondLengthFactor');
        const bondLengthFactorValue = document.getElementById('bondLengthFactorValue');
        bondLengthFactorInput.addEventListener('input', (e) => {
          params.bondLengthFactor = parseFloat(e.target.value);
          bondLengthFactorValue.textContent = params.bondLengthFactor.toFixed(1);
        });

        const forcePPInput = document.getElementById('force_pp');
        const forcePPValue = document.getElementById('force_ppValue');
        forcePPInput.addEventListener('input', (e) => {
          params.force_pp = parseFloat(e.target.value);
          forcePPValue.textContent = params.force_pp.toFixed(2);
        });

        const forcePNInput = document.getElementById('force_pn');
        const forcePNValue = document.getElementById('force_pnValue');
        forcePNInput.addEventListener('input', (e) => {
          params.force_pn = parseFloat(e.target.value);
          forcePNValue.textContent = params.force_pn.toFixed(2);
        });

        const forceNNInput = document.getElementById('force_nn');
        const forceNNValue = document.getElementById('force_nnValue');
        forceNNInput.addEventListener('input', (e) => {
          params.force_nn = parseFloat(e.target.value);
          forceNNValue.textContent = params.force_nn.toFixed(2);
        });

        const dtInput = document.getElementById('dt');
        const dtValue = document.getElementById('dtValue');
        dtInput.addEventListener('input', (e) => {
          params.dt = parseFloat(e.target.value);
          dtValue.textContent = params.dt.toFixed(3);
        });
      },

      setupOverlay() {
        this.playButton.addEventListener('click', () => {
          Simulation.play();
          this.hideOverlay();
        });

        this.resetButton.addEventListener('click', () => {
          Simulation.reset();
          this.showOverlay();
        });
      },

      setupCanvas() {
        const canvas = document.getElementById('simulationCanvas');
        canvas.addEventListener('click', () => {
          Simulation.pause();
          this.showOverlay();
        });
      },

      showOverlay() {
        this.overlay.classList.add('active');
      },

      hideOverlay() {
        this.overlay.classList.remove('active');
      }
    };

    // Initialize everything on page load
    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('simulationCanvas');
      Simulation.init(canvas, params);
      UIController.init();
    });
  </script>

  <script src="../../assets/js/main.js"></script>
</body>
</html>