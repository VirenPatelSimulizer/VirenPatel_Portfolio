<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Viren Patel - Technology enthusiast, podcast host, and simulation developer. Explore my portfolio of projects and listen to Decoded with Viren.">
  <title>A & B Particle Simulation - Viren Patel</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/css/styles.css">

  <!-- Google Analytics (GA4) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DMXF1FG10E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    // Your measurement ID
    gtag('config', 'G-DMXF1FG10E', {
      // optional advanced settings
      // 'page_title': document.title,
      // 'page_path': location.pathname
    });
  </script>
  <!-- End Google Analytics -->

  <style>
    /* Simulation Container */
    .simulation-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
      margin-top: 60px;
      display: flex;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      overflow: hidden;
    }

    /* Sidebar Styles */
    .simulation-sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 320px;
      max-width: 320px;
      height: 100%;
      max-height: 100vh;
      background: rgba(20, 20, 40, 0.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      padding: 20px;
      box-sizing: border-box;
      overflow-y: hidden;
      overflow-x: hidden;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
      color: #e0e0e0;
    }

    .simulation-sidebar.collapsed {
      transform: translateX(-100%);
    }

    .sidebar-toggle {
      position: fixed;
      left: 0;
      top: 20px;
      width: 40px;
      height: 40px;
      background: rgba(20, 20, 40, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: none;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 101;
    }

    .simulation-sidebar:not(.collapsed) .sidebar-toggle {
      left: 320px;
    }

    .simulation-sidebar.collapsed .sidebar-toggle {
      left: 0;
    }

    .sidebar-toggle:hover {
      background: rgba(30, 30, 50, 0.95);
    }

    .sidebar-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
    }

    .sidebar-control-btn {
      position: fixed;
      left: 320px;
      top: 80px;
      width: 40px;
      height: 40px;
      background: rgba(74, 158, 255, 0.3);
      border: 1px solid rgba(74, 158, 255, 0.6);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4a9eff;
      font-size: 20px;
      font-weight: bold;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 150;
    }

    .sidebar-control-btn:hover {
      background: rgba(74, 158, 255, 0.5);
      border-color: #4a9eff;
      transform: scale(1.1);
    }

    .simulation-sidebar.collapsed ~ .simulation-canvas-wrapper .sidebar-control-btn {
      left: 20px;
      top: 80px;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #b0b0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-value {
      float: right;
      color: #4a9eff;
      font-weight: 600;
    }

    .control-input {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .control-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .control-input::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    .control-select {
      width: 100%;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      outline: none;
    }

    .control-select option {
      background: #1a1a2e;
      color: #e0e0e0;
    }

    .delay-group {
      margin-top: 10px;
      padding: 10px;
      background: rgba(74, 158, 255, 0.1);
      border-left: 3px solid #4a9eff;
      border-radius: 4px;
      display: none;
    }

    .delay-group.visible {
      display: block;
    }

    /* Canvas Styles */
    .simulation-canvas-wrapper {
      flex: 1;
      position: relative;
    }

    #simulationCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    /* Back Button */
    .back-button {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #e0e0e0;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      z-index: 150;
    }

    .back-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateX(-3px);
      color: #4a9eff;
    }

    .back-arrow {
      font-size: 18px;
      transition: transform 0.3s;
    }

    .back-button:hover .back-arrow {
      transform: translateX(-3px);
    }

    /* Overlay Controls */
    .simulation-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      gap: 20px;
      z-index: 50;
    }

    .simulation-overlay.active {
      display: flex;
    }

    .overlay-button {
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .overlay-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(74, 158, 255, 0.3);
    }

    .overlay-button.play {
      background: rgba(74, 158, 255, 0.2);
      border-color: #4a9eff;
    }

    .overlay-button.reset {
      background: rgba(255, 74, 74, 0.2);
      border-color: #ff4a4a;
    }

    /* Stats Display */
    .simulation-stats {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #e0e0e0;
      font-size: 12px;
      line-height: 1.6;
      z-index: 50;
      display: flex;
      gap: 20px;
    }

    .stat-item {
      display: flex;
      gap: 8px;
    }

    .stat-value {
      color: #4a9eff;
      font-weight: 600;
    }

    .stat-particle-a {
      color: #00d4ff;
    }

    .stat-particle-b {
      color: #ff6b35;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .simulation-sidebar {
        width: 280px;
      }

      .simulation-sidebar.collapsed {
        transform: translateX(-280px);
      }

      .overlay-button {
        padding: 12px 30px;
        font-size: 14px;
      }

      .back-text {
        display: none;
      }

      .simulation-stats {
        font-size: 10px;
        padding: 10px 12px;
        gap: 12px;
        flex-wrap: wrap;
      }
    }

    @media (max-width: 480px) {
      .simulation-sidebar {
        width: 240px;
      }

      .simulation-sidebar.collapsed {
        transform: translateX(-240px);
      }
    }
  </style>
</head>
<body>
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
 
  <!-- Navbar -->
  <header>
    <nav>
      <div class="logo">
        <a href="index.html">Viren Patel</a>
      </div>
      <div class="logo">
        <a>A & B Particle Simulation</a>
      </div>
      <ul class="nav-links">
        <li><a href="#hero">Home</a></li>
        <li><a href="portfolio.html">Portfolio</a></li>
        <li><a href="simulations/index.html">Simulations</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
  </header>
 
  <!--  Add Simulation below here  -->
  <div class="simulation-container">
    <!-- Sidebar -->
    <div class="simulation-sidebar" id="simulationSidebar">
      <div class="sidebar-toggle" id="sidebarToggle">&#9776;</div>
      <div class="sidebar-title">Simulation Controls</div>
      
      <div class="control-group">
        <label class="control-label">
          Wall Mode
        </label>
        <select class="control-select" id="wallMode">
          <option value="solid">Solid Walls (Bounce)</option>
          <option value="wrap">Wrap-Around (Continuous)</option>
        </select>
      </div>

      <div class="control-group">
        <label class="control-label">
          Spawn Mode
        </label>
        <select class="control-select" id="spawnMode">
          <option value="both">Both Together</option>
          <option value="aFirst">A Particles First</option>
          <option value="bFirst">B Particles First</option>
        </select>
      </div>

      <div class="control-group delay-group" id="delayGroup">
        <label class="control-label">
          Spawn Delay (seconds)
          <span class="control-value" id="spawnDelayValue">10.0</span>
        </label>
        <input type="range" class="control-input" id="spawnDelay" min="0" max="60" step="0.5" value="10">
      </div>

      <div class="control-group">
        <label class="control-label">
          A Particle Count
          <span class="control-value" id="particleACountValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleACount" min="10" max="1000" step="10" value="50">
      </div>

      <div class="control-group">
        <label class="control-label">
          B Particle Count
          <span class="control-value" id="particleBCountValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleBCount" min="10" max="1000" step="10" value="50">
      </div>

      <div class="control-group">
        <label class="control-label">
          A Particle Speed
          <span class="control-value" id="speedAValue">1.0</span>
        </label>
        <input type="range" class="control-input" id="speedA" min="0" max="5" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          B Particle Speed
          <span class="control-value" id="speedBValue">1.0</span>
        </label>
        <input type="range" class="control-input" id="speedB" min="0" max="5" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Radius Scale
          <span class="control-value" id="radiusScaleValue">1.0</span>
        </label>
        <input type="range" class="control-input" id="radiusScale" min="0.5" max="3" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Bond Length Factor
          <span class="control-value" id="bondLengthFactorValue">1.0</span>
          <label style="float: right; display: flex; align-items: center; gap: 5px; font-size: 12px; text-transform: none; cursor: pointer;">
            <input type="checkbox" id="simulateBonds" checked style="cursor: pointer; width: 16px; height: 16px;">
            <span>Show Bonds</span>
          </label>
        </label>
        <input type="range" class="control-input" id="bondLengthFactor" min="0.5" max="3" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Force A-A (-ve attract / +ve repel)
          <span class="control-value" id="force_aaValue">0.5</span>
        </label>
        <input type="range" class="control-input" id="force_aa" min="-5" max="5" step="0.1" value="0.5">
      </div>

      <div class="control-group">
        <label class="control-label">
          Force A-B (-ve attract / +ve repel)
          <span class="control-value" id="force_abValue">-0.3</span>
        </label>
        <input type="range" class="control-input" id="force_ab" min="-5" max="5" step="0.1" value="-0.3">
      </div>

      <div class="control-group">
        <label class="control-label">
          Force B-B (-ve attract / +ve repel)
          <span class="control-value" id="force_bbValue">0.5</span>
        </label>
        <input type="range" class="control-input" id="force_bb" min="-5" max="5" step="0.1" value="0.5">
      </div>
    </div>

    <!-- Canvas Wrapper -->
    <div class="simulation-canvas-wrapper">
      <canvas id="simulationCanvas"></canvas>

      <!-- Sidebar Control Button -->
      <div class="sidebar-control-btn" id="sidebarControlBtn">←</div>

      <!-- Back Button -->
      <a href="../index.html" class="back-button" id="backButton">
        <span class="back-arrow">←</span>
        <span class="back-text">Back to Simulations</span>
      </a>

      <!-- Stats Display -->
      <div class="simulation-stats" id="statsDisplay">
        <div class="stat-item">
          <span>FPS:</span>
          <span class="stat-value" id="fpsValue">60</span>
        </div>
        <div class="stat-item">
          <span class="stat-particle-a">A Particles:</span>
          <span class="stat-value stat-particle-a" id="particleACount">50</span>
        </div>
        <div class="stat-item">
          <span class="stat-particle-b">B Particles:</span>
          <span class="stat-value stat-particle-b" id="particleBCount">50</span>
        </div>
        <div class="stat-item">
          <span>Total Energy:</span>
          <span class="stat-value" id="totalEnergy">0</span>
        </div>
      </div>

      <!-- Overlay Controls -->
      <div class="simulation-overlay active" id="simulationOverlay">
        <button class="overlay-button play" id="playButton">Play</button>
        <button class="overlay-button reset" id="resetButton">Reset</button>
      </div>
    </div>
  </div>
  <!--  Add Simulation End here  -->
 
  <!-- Footer -->
  <footer>
    <div class="footer-content">
      <p>&copy; 2025 Viren Patel. All rights reserved.</p>
      <div class="social-links">
        <a href="mailto:virenp.jobs@gmail.com">Email</a>
        <a href="https://www.linkedin.com/in/-virenpatel" target="_blank">LinkedIn</a>
        <a href="https://calendly.com/virenp-jobs/new-connection-linkedin" target="_blank">Schedule Call</a>
      </div>
    </div>
  </footer>

  <script>
    /**
     * A & B Particle Physics Engine
     * Simple collision-based physics with elastic collisions
     */

    const params = {
      particleACount: 50,
      particleBCount: 50,
      speedA: 100.0,
      speedB: 100.0,
      radiusScale: 1.0,
      bondLengthFactor: 1.0,
      force_aa: 0.5,
      force_ab: -0.3,
      force_bb: 0.5,
      dt: 0.016,
      spawnMode: 'both',
      spawnDelay: 10.0,
      wallMode: 'solid',
      simulateBonds: true
    };

    const BASE_RADIUS = 5;
    const RESTITUTION = 1.0; // Elastic collisions (1.0 = perfectly elastic)

    class Particle {
      constructor(x, y, particleType, speed) {
        this.pos = {x, y};
        this.vel = {x: 0, y: 0};
        this.force = {x: 0, y: 0};

        // particleType is either 'A' or 'B'
        this.type = particleType;
        this.mass = 1.0;
        this.radius = params.radiusScale * BASE_RADIUS;

        // Random initial velocity direction
        const angle = Math.random() * Math.PI * 2;
        this.vel.x = Math.cos(angle) * speed;
        this.vel.y = Math.sin(angle) * speed;

        // A particles are cyan/blue, B particles are orange/red
        this.color = this.type === 'A' ? {r: 0, g: 212, b: 255} : {r: 255, g: 107, b: 53};
      }

      getKineticEnergy() {
        return 0.5 * this.mass * (this.vel.x * this.vel.x + this.vel.y * this.vel.y);
      }

      update(dt) {
        // Update position based on velocity
        this.pos.x += this.vel.x * dt;
        this.pos.y += this.vel.y * dt;
      }

      handleBoundaries(width, height) {
        if (params.wallMode === 'solid') {
          // Bounce off walls
          if (this.pos.x - this.radius < 0) {
            this.pos.x = this.radius;
            this.vel.x = Math.abs(this.vel.x); // Ensure moving right
          } else if (this.pos.x + this.radius > width) {
            this.pos.x = width - this.radius;
            this.vel.x = -Math.abs(this.vel.x); // Ensure moving left
          }
          if (this.pos.y - this.radius < 0) {
            this.pos.y = this.radius;
            this.vel.y = Math.abs(this.vel.y); // Ensure moving down
          } else if (this.pos.y + this.radius > height) {
            this.pos.y = height - this.radius;
            this.vel.y = -Math.abs(this.vel.y); // Ensure moving up
          }
        } else if (params.wallMode === 'wrap') {
          // Wrap around edges
          if (this.pos.x < -this.radius) this.pos.x = width + this.radius;
          else if (this.pos.x > width + this.radius) this.pos.x = -this.radius;
          if (this.pos.y < -this.radius) this.pos.y = height + this.radius;
          else if (this.pos.y > height + this.radius) this.pos.y = -this.radius;
        }
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.6)`;
      }
    }

    let particles = [];
    let bonds = [];

    function getInteractionForce(typeI, typeJ) {
      if (typeI === 'A' && typeJ === 'A') return params.force_aa;  // A-A repel
      if (typeI === 'B' && typeJ === 'B') return params.force_bb;  // B-B repel
      return params.force_ab;  // A-B attract
    }

    function updateBonds() {
      if (!params.simulateBonds) {
        bonds = [];
        return;
      }

      bonds = [];

      // Check all particle pairs
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const pi = particles[i];
          const pj = particles[j];

          // Get force between these particle types
          const forceMultiplier = getInteractionForce(pi.type, pj.type);

          // Only create bonds for attractive forces (negative values)
          if (forceMultiplier < 0) {
            // Calculate distance
            const dx = pj.pos.x - pi.pos.x;
            const dy = pj.pos.y - pi.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Bond length is bondLengthFactor times the sum of radii
            const bondLength = params.bondLengthFactor * (pi.radius + pj.radius);

            // Create bond if within bond length
            if (dist <= bondLength) {
              bonds.push({ i, j });
            }
          }
        }
      }
    }

    function initParticles(countA, countB, speedA, speedB, canvas) {
      particles = [];

      // Function to check if a position overlaps with existing particles
      function isValidPosition(x, y, radius) {
        for (let p of particles) {
          const dx = x - p.pos.x;
          const dy = y - p.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < radius + p.radius) {
            return false;
          }
        }
        return true;
      }

      // Spawn A particles
      for (let i = 0; i < countA; i++) {
        let attempts = 0;
        let x, y;
        const radius = params.radiusScale * BASE_RADIUS;

        // Try to find a non-overlapping position
        do {
          x = radius + Math.random() * (canvas.width - 2 * radius);
          y = radius + Math.random() * (canvas.height - 2 * radius);
          attempts++;
        } while (!isValidPosition(x, y, radius) && attempts < 100);

        if (attempts < 100) {
          particles.push(new Particle(x, y, 'A', speedA));
        }
      }

      // Spawn B particles
      for (let i = 0; i < countB; i++) {
        let attempts = 0;
        let x, y;
        const radius = params.radiusScale * BASE_RADIUS;

        // Try to find a non-overlapping position
        do {
          x = radius + Math.random() * (canvas.width - 2 * radius);
          y = radius + Math.random() * (canvas.height - 2 * radius);
          attempts++;
        } while (!isValidPosition(x, y, radius) && attempts < 100);

        if (attempts < 100) {
          particles.push(new Particle(x, y, 'B', speedB));
        }
      }
    }

    function computeForces() {
      const MAX_FORCE = 10;
      const FORCE_STRENGTH = 1000; // Adjust this to control force intensity

      // Reset all forces
      for (let p of particles) {
        p.force.x = 0;
        p.force.y = 0;
      }

      // Calculate forces between all particle pairs
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const pi = particles[i];
          const pj = particles[j];

          // Calculate distance vector (from pi to pj)
          const dx = pj.pos.x - pi.pos.x;
          const dy = pj.pos.y - pi.pos.y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq);

          if (dist < 0.1) continue; // Avoid division by zero

          // Get force multiplier based on particle types
          const forceMultiplier = getInteractionForce(pi.type, pj.type);

          // Calculate force magnitude (inverse square law)
          // IMPORTANT: Negative force = attraction (pull together)
          //            Positive force = repulsion (push apart)
          let forceMag = (forceMultiplier * FORCE_STRENGTH) / distSq;

          // Clamp force to prevent extreme values
          forceMag = Math.max(-MAX_FORCE, Math.min(MAX_FORCE, forceMag));

          // Normalize direction vector (points from pi to pj)
          const nx = dx / dist;
          const ny = dy / dist;

          // For attraction (negative force): pull particles together
          //   - We want pi to move TOWARD pj (in direction of nx, ny)
          //   - forceMag is negative, so -forceMag is positive
          //   - Force should be in direction of (nx, ny)
          //
          // For repulsion (positive force): push particles apart
          //   - We want pi to move AWAY from pj (opposite of nx, ny)
          //   - forceMag is positive, so -forceMag is negative
          //   - Force should be in opposite direction of (nx, ny)
          //
          // Solution: negate the force to flip the direction
          const fx = -nx * forceMag;
          const fy = -ny * forceMag;

          // Apply forces (Newton's third law)
          pi.force.x += fx;
          pi.force.y += fy;
          pj.force.x -= fx;
          pj.force.y -= fy;
        }
      }
    }

    function handleCollisions() {
      // Check all particle pairs for collisions
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const pi = particles[i];
          const pj = particles[j];

          // Calculate distance between particles
          const dx = pj.pos.x - pi.pos.x;
          const dy = pj.pos.y - pi.pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = pi.radius + pj.radius;

          // Check if particles are overlapping
          if (dist < minDist && dist > 0) {
            // Collision normal (normalized direction vector)
            const nx = dx / dist;
            const ny = dy / dist;

            // Separate particles to prevent overlap
            const overlap = minDist - dist;
            const separationX = nx * overlap * 0.5;
            const separationY = ny * overlap * 0.5;

            pi.pos.x -= separationX;
            pi.pos.y -= separationY;
            pj.pos.x += separationX;
            pj.pos.y += separationY;

            // Calculate relative velocity
            const dvx = pj.vel.x - pi.vel.x;
            const dvy = pj.vel.y - pi.vel.y;

            // Calculate relative velocity in collision normal direction
            const dvn = dvx * nx + dvy * ny;

            // Only resolve if particles are moving towards each other
            if (dvn < 0) {
              // Calculate impulse scalar (for equal mass elastic collision)
              const impulse = -(1 + RESTITUTION) * dvn / (1/pi.mass + 1/pj.mass);

              // Apply impulse to both particles
              const impulseX = impulse * nx;
              const impulseY = impulse * ny;

              pi.vel.x -= impulseX / pi.mass;
              pi.vel.y -= impulseY / pi.mass;
              pj.vel.x += impulseX / pj.mass;
              pj.vel.y += impulseY / pj.mass;
            }
          }
        }
      }
    }

    function step(dt, canvas) {
      // Compute forces between particles
      computeForces();

      // Apply forces to update velocities
      for (let p of particles) {
        p.vel.x += (p.force.x / p.mass) * dt;
        p.vel.y += (p.force.y / p.mass) * dt;
      }

      // Update all particle positions
      for (let p of particles) {
        p.update(dt);
      }

      // Handle particle-particle collisions
      handleCollisions();

      // Handle boundary collisions
      for (let p of particles) {
        p.handleBoundaries(canvas.width, canvas.height);
      }

      // Update bonds between particles
      updateBonds();
    }

    function setParams(newParams) {
      Object.assign(params, newParams);
    }

    function reset(canvas) {
      initParticles(params.particleACount, params.particleBCount, params.speedA, params.speedB, canvas);
    }

    const Simulation = {
      canvas: null,
      ctx: null,
      isPaused: true,
      lastTime: 0,
      fps: 60,
      frameCount: 0,
      fpsTime: 0,
      spawnTimer: 0,
      secondGroupSpawned: false,

      init(canvasElement, initialParams) {
        this.canvas = canvasElement;
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        Object.assign(params, initialParams);
        this.createParticles();
        this.lastTime = performance.now();
        this.animate();
      },

      resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      },

      createParticles() {
        this.spawnTimer = 0;
        this.secondGroupSpawned = false;

        if (params.spawnMode === 'both') {
          initParticles(params.particleACount, params.particleBCount, params.speedA, params.speedB, this.canvas);
          this.secondGroupSpawned = true;
        } else if (params.spawnMode === 'aFirst') {
          initParticles(params.particleACount, 0, params.speedA, params.speedB, this.canvas);
        } else if (params.spawnMode === 'bFirst') {
          initParticles(0, params.particleBCount, params.speedA, params.speedB, this.canvas);
        }
      },

      checkDelayedSpawn(dt) {
        if (this.secondGroupSpawned) return;
        this.spawnTimer += dt;

        if (this.spawnTimer >= params.spawnDelay) {
          if (params.spawnMode === 'aFirst') {
            for (let i = 0; i < params.particleBCount; i++) {
              particles.push(new Particle(Math.random() * this.canvas.width, Math.random() * this.canvas.height, 'B', params.speedB));
            }
          } else if (params.spawnMode === 'bFirst') {
            for (let i = 0; i < params.particleACount; i++) {
              particles.push(new Particle(Math.random() * this.canvas.width, Math.random() * this.canvas.height, 'A', params.speedA));
            }
          }
          this.secondGroupSpawned = true;
        }
      },

      animate() {
        requestAnimationFrame(() => this.animate());
        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;

        this.frameCount++;
        this.fpsTime += deltaTime;
        if (this.fpsTime >= 1) {
          this.fps = Math.round(this.frameCount / this.fpsTime);
          this.frameCount = 0;
          this.fpsTime = 0;
        }

        if (!this.isPaused) {
          this.update(deltaTime);
        }
        this.draw();
        this.updateStats();
      },

      update(dt) {
        dt = Math.min(dt, 0.033);
        this.checkDelayedSpawn(dt);
        step(params.dt, this.canvas);
      },

      draw() {
        this.ctx.fillStyle = 'rgba(10, 10, 10, 1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw bonds first (so they appear behind particles)
        if (params.simulateBonds && bonds.length > 0) {
          this.ctx.strokeStyle = 'rgba(255, 255, 100, 0.5)';
          this.ctx.lineWidth = 2;
          for (const bond of bonds) {
            const pi = particles[bond.i];
            const pj = particles[bond.j];
            this.ctx.beginPath();
            this.ctx.moveTo(pi.pos.x, pi.pos.y);
            this.ctx.lineTo(pj.pos.x, pj.pos.y);
            this.ctx.stroke();
          }
        }

        // Draw all particles
        for (const p of particles) {
          p.draw(this.ctx);
        }
        this.ctx.shadowBlur = 0;
      },

      updateStats() {
        document.getElementById('fpsValue').textContent = this.fps;
        let particleACount = 0, particleBCount = 0, totalEnergy = 0;
        for (const p of particles) {
          if (p.type === 'A') particleACount++;
          else particleBCount++;
          totalEnergy += p.getKineticEnergy();
        }
        document.getElementById('particleACount').textContent = particleACount;
        document.getElementById('particleBCount').textContent = particleBCount;
        //document.getElementById('totalEnergy').textContent = Math.round(totalEnergy);
      },

      reset() {
        this.pause();
        this.createParticles();
        this.draw();
      },

      pause() {
        this.isPaused = true;
      },

      play() {
        this.isPaused = false;
        this.lastTime = performance.now();
      }
    };

    // UI Controller
    const UIController = {
      sidebar: null,
      overlay: null,
      playButton: null,
      resetButton: null,

      init() {
        this.sidebar = document.getElementById('simulationSidebar');
        this.overlay = document.getElementById('simulationOverlay');
        this.playButton = document.getElementById('playButton');
        this.resetButton = document.getElementById('resetButton');

        this.setupSidebarToggle();
        this.setupControls();
        this.setupOverlay();
        this.setupCanvas();
        this.showOverlay();
      },

      setupSidebarToggle() {
        const toggle = document.getElementById('sidebarToggle');
        const controlBtn = document.getElementById('sidebarControlBtn');

        const updateButtons = () => {
          const isCollapsed = this.sidebar.classList.contains('collapsed');
          toggle.textContent = isCollapsed ? '☰' : '✕';
          controlBtn.textContent = isCollapsed ? '→' : '←';
        };

        toggle.addEventListener('click', () => {
          this.sidebar.classList.toggle('collapsed');
          updateButtons();
        });

        controlBtn.addEventListener('click', () => {
          this.sidebar.classList.toggle('collapsed');
          updateButtons();
        });

        // Initialize button states
        updateButtons();
      },

      setupControls() {
        const wallModeSelect = document.getElementById('wallMode');
        wallModeSelect.addEventListener('change', (e) => {
          params.wallMode = e.target.value;
        });

        const spawnModeSelect = document.getElementById('spawnMode');
        const delayGroup = document.getElementById('delayGroup');
        spawnModeSelect.addEventListener('change', (e) => {
          params.spawnMode = e.target.value;
          if (params.spawnMode === 'both') {
            delayGroup.classList.remove('visible');
          } else {
            delayGroup.classList.add('visible');
          }
        });

        const spawnDelayInput = document.getElementById('spawnDelay');
        const spawnDelayValue = document.getElementById('spawnDelayValue');
        spawnDelayInput.addEventListener('input', (e) => {
          params.spawnDelay = parseFloat(e.target.value);
          spawnDelayValue.textContent = params.spawnDelay.toFixed(1);
        });

        const particleACountInput = document.getElementById('particleACount');
        const particleACountValue = document.getElementById('particleACountValue');
        particleACountInput.addEventListener('input', (e) => {
          params.particleACount = parseInt(e.target.value);
          particleACountValue.textContent = params.particleACount;
        });

        const particleBCountInput = document.getElementById('particleBCount');
        const particleBCountValue = document.getElementById('particleBCountValue');
        particleBCountInput.addEventListener('input', (e) => {
          params.particleBCount = parseInt(e.target.value);
          particleBCountValue.textContent = params.particleBCount;
        });

        const speedAInput = document.getElementById('speedA');
        const speedAValue = document.getElementById('speedAValue');
        speedAInput.addEventListener('input', (e) => {
          params.speedA = parseFloat(e.target.value);
          speedAValue.textContent = params.speedA.toFixed(1);
        });

        const speedBInput = document.getElementById('speedB');
        const speedBValue = document.getElementById('speedBValue');
        speedBInput.addEventListener('input', (e) => {
          params.speedB = parseFloat(e.target.value);
          speedBValue.textContent = params.speedB.toFixed(1);
        });

        const radiusScaleInput = document.getElementById('radiusScale');
        const radiusScaleValue = document.getElementById('radiusScaleValue');
        radiusScaleInput.addEventListener('input', (e) => {
          params.radiusScale = parseFloat(e.target.value);
          radiusScaleValue.textContent = params.radiusScale.toFixed(1);
        });

        const bondLengthFactorInput = document.getElementById('bondLengthFactor');
        const bondLengthFactorValue = document.getElementById('bondLengthFactorValue');
        bondLengthFactorInput.addEventListener('input', (e) => {
          params.bondLengthFactor = parseFloat(e.target.value);
          bondLengthFactorValue.textContent = params.bondLengthFactor.toFixed(1);
        });

        const forceAAInput = document.getElementById('force_aa');
        const forceAAValue = document.getElementById('force_aaValue');
        forceAAInput.addEventListener('input', (e) => {
          params.force_aa = parseFloat(e.target.value);
          forceAAValue.textContent = params.force_aa.toFixed(1);
        });

        const forceABInput = document.getElementById('force_ab');
        const forceABValue = document.getElementById('force_abValue');
        forceABInput.addEventListener('input', (e) => {
          params.force_ab = parseFloat(e.target.value);
          forceABValue.textContent = params.force_ab.toFixed(1);
        });

        const forceBBInput = document.getElementById('force_bb');
        const forceBBValue = document.getElementById('force_bbValue');
        forceBBInput.addEventListener('input', (e) => {
          params.force_bb = parseFloat(e.target.value);
          forceBBValue.textContent = params.force_bb.toFixed(1);
        });

        const simulateBondsCheckbox = document.getElementById('simulateBonds');
        simulateBondsCheckbox.addEventListener('change', (e) => {
          params.simulateBonds = e.target.checked;
        });
      },

      setupOverlay() {
        this.playButton.addEventListener('click', () => {
          Simulation.play();
          this.hideOverlay();
        });

        this.resetButton.addEventListener('click', () => {
          Simulation.reset();
          this.showOverlay();
        });
      },

      setupCanvas() {
        const canvas = document.getElementById('simulationCanvas');
        canvas.addEventListener('click', () => {
          Simulation.pause();
          this.showOverlay();
        });
      },

      showOverlay() {
        this.overlay.classList.add('active');
      },

      hideOverlay() {
        this.overlay.classList.remove('active');
      }
    };

    // Initialize everything on page load
    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('simulationCanvas');
      Simulation.init(canvas, params);
      UIController.init();
    });
  </script>

  <script src="../../assets/js/main.js"></script>
</body>
</html>