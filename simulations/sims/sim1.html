<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Viren Patel - Technology enthusiast, podcast host, and simulation developer. Explore my portfolio of projects and listen to Decoded with Viren.">
  <title>Brownian Motion Simulation - Viren Patel</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/css/styles.css">
  <style>
     /* Simulation Container */
    .simulation-container {
      position: relative;
      width: 100%;
      min-height: calc(100vh - 80px - 100px);
      margin-top: 70px; /* space below navbar */
      display: flex;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      overflow: hidden;
    }

    /* Sidebar Styles */
    .simulation-sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 300px;
      height: 100%;
      background: rgba(20, 20, 40, 0.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      padding: 20px;
      box-sizing: border-box;
      /*overflow-y: auto;*/
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
      color: #e0e0e0;
    }

    .simulation-sidebar.collapsed {
      transform: translateX(-300px);
    }

    .sidebar-toggle {
     position: absolute;
     right: -40px;  /* Should be OUTSIDE the sidebar */
     top: 20px;
     width: 40px;
     height: 40px;
     background: rgba(20, 20, 40, 0.95);
     border: 1px solid rgba(255, 255, 255, 0.1);
     border-left: none;
     border-radius: 0 8px 8px 0;
     cursor: pointer;
     display: flex;  /* Make sure this is here */
     align-items: center;
     justify-content: center;
     color: #fff;
     font-size: 20px;
     transition: background 0.2s;
     z-index: 101;
     }

    .sidebar-toggle:hover {
      background: rgba(30, 30, 50, 0.95);
    }
    .simulation-sidebar.collapsed .sidebar-toggle {
     position: fixed;
     left: 0;
     right: auto;
     border-radius: 0 8px 8px 0;
     }

    .sidebar-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #b0b0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-value {
      float: right;
      color: #4a9eff;
      font-weight: 600;
    }

    .control-input {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .control-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .control-input::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    /* Canvas Styles */
    .simulation-canvas-wrapper {
      flex: 1;
      position: relative;
      /*transition: margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1); removed to fix the canvas */  
    }

    /*
    .simulation-canvas-wrapper.sidebar-visible {
      margin-left: 300px;
    }*/

    #simulationCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    /* Overlay Controls */
    .simulation-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      gap: 20px;
      z-index: 50;
    }

    .simulation-overlay.active {
      display: flex;
    }

    .overlay-button {
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .overlay-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(74, 158, 255, 0.3);
    }

    .overlay-button.play {
      background: rgba(74, 158, 255, 0.2);
      border-color: #4a9eff;
    }

    .overlay-button.reset {
      background: rgba(255, 74, 74, 0.2);
      border-color: #ff4a4a;
    }

    /* Stats Display */
    .simulation-stats {
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #e0e0e0;
      font-size: 12px;
      line-height: 1.6;
      z-index: 50;
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }

    .stat-value {
      color: #4a9eff;
      font-weight: 600;
    }

    /* Back Button */
    .back-button {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #e0e0e0;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      z-index: 150;
    }

    .back-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateX(-3px);
      color: #4a9eff;
    }

    .back-arrow {
      font-size: 18px;
      transition: transform 0.3s;
    }

    .back-button:hover .back-arrow {
      transform: translateX(-3px);
    }

    

    @media (max-width: 768px) {
      .back-button {
        top: 10px;
        right: 10px;
        padding: 8px 15px;
        font-size: 12px;
      }
      
      .back-text {
        display: none;
      }
      
      .back-arrow {
        font-size: 20px;
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .simulation-sidebar {
        width: 250px;
      }

      .simulation-sidebar.collapsed {
        transform: translateX(-250px);
      }

      .simulation-canvas-wrapper.sidebar-visible {
        margin-left: 250px;
      }

      .overlay-button {
        padding: 12px 30px;
        font-size: 14px;
      }
    }

   


    /* Help Icon */
    .help-icon {
      position: relative;
      width: 20px;
      height: 20px;
      background: rgba(74, 158, 255, 0.2);
      border: 2px solid #4a9eff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: help;
      transition: all 0.3s ease;
      margin-left: 1rem;
    }

    .help-icon span {
      color: #4a9eff;
      font-size: 18px;
      font-weight: 700;
      user-select: none;
      line-height: 1;
    }

    .help-icon:hover {
      background: rgba(74, 158, 255, 0.3);
      transform: scale(1.1);
    }

    /* Help Tooltip */
    .help-tooltip {
      position: absolute;
      top: calc(100% + 15px);
      right: 0;
      width: 350px;
      background: rgba(20, 20, 40, 0.98);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(74, 158, 255, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      pointer-events: none;
    }

    .help-tooltip::before {
      content: '';
      position: absolute;
      top: -8px;
      right: 12px;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 8px solid rgba(74, 158, 255, 0.3);
    }

    .help-icon:hover .help-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .help-tooltip h3 {
      color: #4a9eff;
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 0.75rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 0.5rem;
    }

    .help-tooltip p {
      color: #e0e0e0;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0 0 0.75rem 0;
    }

    .help-tooltip ul {
      list-style: none;
      padding: 0;
      margin: 0 0 0.75rem 0;
    }

    .help-tooltip li {
      color: #b0b0b0;
      font-size: 0.85rem;
      line-height: 1.6;
      margin-bottom: 0.5rem;
      padding-left: 1.25rem;
      position: relative;
    }

    .help-tooltip li::before {
      content: '→';
      position: absolute;
      left: 0;
      color: #4a9eff;
    }

    .help-tooltip strong {
      color: #fff;
      font-weight: 600;
    }

    .help-controls {
      background: rgba(74, 158, 255, 0.1);
      border-left: 3px solid #4a9eff;
      padding: 0.75rem;
      border-radius: 4px;
      font-size: 0.85rem;
      margin-bottom: 0 !important;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .help-tooltip {
        width: 280px;
        right: -10px;
      }
      
      .help-icon {
        margin-left: 0.5rem;
        width: 28px;
        height: 28px;
      }
      
      .help-icon span {
        font-size: 16px;
      }
    }

    @media (max-width: 480px) {
      .help-tooltip {
        width: calc(100vw - 40px);
        right: -20px;
      }
    }
    /* Simulation Container */
    .simulation-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 80px);
      display: flex;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      overflow: hidden;
    }

    /* Sidebar Styles */
    .simulation-sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 300px;
      height: 100%;
      background: rgba(20, 20, 40, 0.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
      color: #e0e0e0;
    }

    .simulation-sidebar.collapsed {
      transform: translateX(-300px);
    }

    .sidebar-toggle {
      position: absolute;
      right: -40px;
      top: 20px;
      width: 40px;
      height: 40px;
      background: rgba(20, 20, 40, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: none;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      transition: background 0.2s;
      z-index: 101;
    }

    .sidebar-toggle:hover {
      background: rgba(30, 30, 50, 0.95);
    }

    .sidebar-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #b0b0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-value {
      float: right;
      color: #4a9eff;
      font-weight: 600;
    }

    .control-input {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .control-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .control-input::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #4a9eff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-input::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    /* Canvas Styles */
    .simulation-canvas-wrapper {
      flex: 1;
      position: relative;
    }

    #simulationCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    /* Back Button */
    .back-button {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #e0e0e0;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      z-index: 150;
    }

    .back-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateX(-3px);
      color: #4a9eff;
    }

    .back-arrow {
      font-size: 18px;
      transition: transform 0.3s;
    }

    .back-button:hover .back-arrow {
      transform: translateX(-3px);
    }

    /* Overlay Controls */
    .simulation-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      gap: 20px;
      z-index: 50;
    }

    .simulation-overlay.active {
      display: flex;
    }

    .overlay-button {
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .overlay-button:hover {
      background: rgba(30, 30, 50, 0.95);
      border-color: #4a9eff;
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(74, 158, 255, 0.3);
    }

    .overlay-button.play {
      background: rgba(74, 158, 255, 0.2);
      border-color: #4a9eff;
    }

    .overlay-button.reset {
      background: rgba(255, 74, 74, 0.2);
      border-color: #ff4a4a;
    }

    /* Stats Display */
    .simulation-stats {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #e0e0e0;
      font-size: 12px;
      line-height: 1.6;
      z-index: 50;
      display: flex;
      gap: 20px;
    }

    .stat-item {
      display: flex;
      gap: 8px;
    }

    .stat-value {
      color: #4a9eff;
      font-weight: 600;
    }

    

    
  </style>
</head>
<body>
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
 
  <!-- Navbar -->
  <header>
    <nav>
      <div class="logo">
        <a href="index.html">Brownian Motion Simulation</a>
      </div>
      <ul class="nav-links">
        <li><a href="#hero">Home</a></li>
        <li><a href="portfolio.html">Portfolio</a></li>
        <li><a href="simulations/index.html">Simulations</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
  </header>
 
  <!--  Add Simulation below here  -->
  <div class="simulation-container">
    <!-- Sidebar -->
    <div class="simulation-sidebar" id="simulationSidebar">
      <div class="sidebar-toggle" id="sidebarToggle">&#9776;</div>
      <div class="sidebar-title">Simulation Controls</div>
      
      <div class="control-group">
        <label class="control-label">
          Particle Variety
          <span class="control-value" id="varietyValue">1</span>
        </label>
        <input type="range" class="control-input" id="variety" min="1" max="5" value="1">
      </div>

      <div class="control-group">
        <label class="control-label">
          Type A Count
          <span class="control-value" id="particleCountAValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleCountA" min="1" max="1000" value="50">
      </div>

      <div class="control-group">
        <label class="control-label">
          Type B Count
          <span class="control-value" id="particleCountBValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleCountB" min="1" max="1000" value="50">
      </div>

      <div class="control-group">
        <label class="control-label">
          Type C Count
          <span class="control-value" id="particleCountCValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleCountC" min="0" max="1000" value="0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Type D Count
          <span class="control-value" id="particleCountDValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleCountD" min="0" max="1000" value="0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Type E Count
          <span class="control-value" id="particleCountEValue">50</span>
        </label>
        <input type="range" class="control-input" id="particleCountE" min="0" max="1000" value="0">
      </div>

      <div class="control-group">
        <label class="control-label">
          Temperature
          <span class="control-value" id="temperatureValue">5.0</span>
        </label>
        <input type="range" class="control-input" id="temperature" min="1" max="20" step="0.1" value="3">
      </div>
    </div>

    <!-- Canvas Wrapper -->
    <div class="simulation-canvas-wrapper">
      <canvas id="simulationCanvas"></canvas>
      
      <!-- Back Button -->
      <a href="../index.html" class="back-button" id="backButton">
        <span class="back-arrow">←</span>
        <span class="back-text">Back to Simulations</span>
      </a>

      <!-- Stats Display -->
      <div class="simulation-stats" id="statsDisplay">
        <div class="stat-item">
          <span>FPS:</span>
          <span class="stat-value" id="fpsValue">60</span>
        </div>
        <div class="stat-item">
          <span>Total Particles:</span>
          <span class="stat-value" id="totalParticles">100</span>
        </div>
        <div class="stat-item">
          <span>Variety:</span>
          <span class="stat-value" id="currentVariety">1</span>
        </div>
      </div>

      <!-- Overlay Controls -->
      <div class="simulation-overlay active" id="simulationOverlay">
        <button class="overlay-button play" id="playButton">Play</button>
        <button class="overlay-button reset" id="resetButton">Reset</button>
      </div>
    </div>
  </div>
  <!--  Add Simulation End here  -->
 
  <!-- Footer -->
  <footer>
    <div class="footer-content">
      <p>&copy; 2025 Viren Patel. All rights reserved.</p>
      <div class="social-links">
        <a href="mailto:virenp.jobs@gmail.com">Email</a>
        <a href="https://www.linkedin.com/in/-virenpatel" target="_blank">LinkedIn</a>
        <a href="https://calendly.com/virenp-jobs/new-connection-linkedin" target="_blank">Schedule Call</a>
      </div>
    </div>
  </footer>

  <script>
    /**
     * Brownian Motion Simulation Framework
     * A modular system simulating particle Brownian motion with variety-based spawning
     */

    // Global simulation parameters
    const params = {
      variety: 1,
      particleCountA: 50,
      particleCountB: 50,
      particleCountC: 0,
      particleCountD: 0,
      particleCountE: 0,
      temperature: 3.0,
      elasticity: 0.95
    };

    // Particle type colors
    const PARTICLE_COLORS = [
      { r: 74, g: 158, b: 255 },   // Type A - Blue
      { r: 255, g: 107, b: 107 },  // Type B - Red
      { r: 72, g: 187, b: 120 },   // Type C - Green
      { r: 251, g: 191, b: 36 },   // Type D - Yellow
      { r: 167, g: 139, b: 250 }   // Type E - Purple
    ];

    // Particle class representing individual Brownian particles
    class Particle {
      constructor(x, y, type, temperature) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.radius = 4;
        
        // Random velocity based on temperature
        const speed = temperature * 20 * (0.5 + Math.random() * 0.5);
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        
        // Brownian motion parameters
        this.angleChange = 0;
        this.color = PARTICLE_COLORS[type];
      }

      // Update particle position with Brownian motion
      update(dt, temperature) {
        // Apply Brownian motion: random directional changes
        this.angleChange += (Math.random() - 0.5) * 0.2;
        
        // Calculate current speed and adjust based on temperature
        const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const targetSpeed = temperature * 20;
        
        // Gradually adjust speed towards target
        const speedFactor = 1 + (targetSpeed - currentSpeed) * 0.01;
        
        // Apply random walk
        const currentAngle = Math.atan2(this.vy, this.vx);
        const newAngle = currentAngle + this.angleChange;
        
        const newSpeed = currentSpeed * speedFactor;
        this.vx = Math.cos(newAngle) * newSpeed;
        this.vy = Math.sin(newAngle) * newSpeed;
        
        // Damping to prevent infinite acceleration
        this.vx *= 0.99;
        this.vy *= 0.99;
        
        // Update position
        this.x += this.vx * dt;
        this.y += this.vy * dt;
      }

      // Handle collision with another particle
      collide(other, elasticity) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = this.radius + other.radius;

        if (dist < minDist && dist > 0) {
          // Normalize collision vector
          const nx = dx / dist;
          const ny = dy / dist;

          // Relative velocity
          const dvx = this.vx - other.vx;
          const dvy = this.vy - other.vy;

          // Relative velocity in collision normal direction
          const relVelNormal = dvx * nx + dvy * ny;

          // Only resolve if particles are moving toward each other
          if (relVelNormal < 0) {
            // Equal mass assumption for simplicity
            const impulse = relVelNormal * elasticity;

            // Apply impulse to velocities
            this.vx -= impulse * nx;
            this.vy -= impulse * ny;
            other.vx += impulse * nx;
            other.vy += impulse * ny;

            // Separate overlapping particles
            const overlap = minDist - dist;
            const separationX = nx * overlap * 0.5;
            const separationY = ny * overlap * 0.5;
            this.x -= separationX;
            this.y -= separationY;
            other.x += separationX;
            other.y += separationY;
          }
        }
      }

      // Bounce off canvas boundaries
      bounceOffWalls(width, height, elasticity) {
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx = Math.abs(this.vx) * elasticity;
        } else if (this.x + this.radius > width) {
          this.x = width - this.radius;
          this.vx = -Math.abs(this.vx) * elasticity;
        }

        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy = Math.abs(this.vy) * elasticity;
        } else if (this.y + this.radius > height) {
          this.y = height - this.radius;
          this.vy = -Math.abs(this.vy) * elasticity;
        }
      }

      // Render particle
      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
        ctx.fill();
        
        // Add slight glow
        ctx.shadowBlur = 8;
        ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.5)`;
      }
    }

    // Main Simulation object
    const Simulation = {
      canvas: null,
      ctx: null,
      particles: [],
      isPaused: true,
      lastTime: 0,
      fps: 60,
      frameCount: 0,
      fpsTime: 0,

      // Initialize simulation
      init(canvasElement, initialParams) {
        this.canvas = canvasElement;
        this.ctx = this.canvas.getContext('2d');
        
        // Set canvas size
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Apply initial parameters
        Object.assign(params, initialParams);

        // Create initial particles
        this.createParticles();

        // Start animation loop
        this.lastTime = performance.now();
        this.animate();
      },

      // Resize canvas to fit container
      resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      },

      // Get spawn position based on variety and type
      getSpawnPosition(type, variety) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        if (variety === 1) {
          // Uniform spawning anywhere
          return {
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height
          };
        } else if (variety === 2) {
          // Split vertically: Type A left, Type B right
          if (type === 0) {
            return {
              x: Math.random() * cx,
              y: Math.random() * this.canvas.height
            };
          } else {
            return {
              x: cx + Math.random() * cx,
              y: Math.random() * this.canvas.height
            };
          }
        } else {
          // Angular sectors from center
          const anglePerSector = (2 * Math.PI) / variety;
          const sectorAngle = type * anglePerSector;
          
          // Random position within sector
          const angle = sectorAngle + (Math.random() - 0.5) * anglePerSector * 0.9;
          const maxRadius = Math.min(cx, cy) * 0.9;
          const radius = Math.sqrt(Math.random()) * maxRadius;
          
          return {
            x: cx + Math.cos(angle) * radius,
            y: cy + Math.sin(angle) * radius
          };
        }
      },

      // Create particle array based on current parameters
      createParticles() {
        this.particles = [];
        const counts = [
          params.particleCountA,
          params.particleCountB,
          params.particleCountC,
          params.particleCountD,
          params.particleCountE
        ];

        for (let type = 0; type < Math.min(params.variety, 5); type++) {
          for (let i = 0; i < counts[type]; i++) {
            const pos = this.getSpawnPosition(type, params.variety);
            this.particles.push(new Particle(pos.x, pos.y, type, params.temperature));
          }
        }
      },

      // Main animation loop
      animate() {
        requestAnimationFrame(() => this.animate());

        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;

        // Calculate FPS
        this.frameCount++;
        this.fpsTime += deltaTime;
        if (this.fpsTime >= 1) {
          this.fps = Math.round(this.frameCount / this.fpsTime);
          this.frameCount = 0;
          this.fpsTime = 0;
        }

        if (!this.isPaused) {
          this.update(deltaTime);
        }

        this.draw();
        this.updateStats();
      },

      // Update simulation physics
      update(dt) {
        dt = Math.min(dt, 0.033);

        // Update particle positions with Brownian motion
        for (let i = 0; i < this.particles.length; i++) {
          this.particles[i].update(dt, params.temperature);
          this.particles[i].bounceOffWalls(this.canvas.width, this.canvas.height, params.elasticity);
        }

        // Handle collisions (multiple passes for stability)
        for (let pass = 0; pass < 2; pass++) {
          for (let i = 0; i < this.particles.length; i++) {
            for (let j = i + 1; j < this.particles.length; j++) {
              this.particles[i].collide(this.particles[j], params.elasticity);
            }
          }
        }
      },

      // Render simulation
      draw() {
        // Clear canvas
        this.ctx.fillStyle = 'rgba(10, 10, 10, 1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw all particles
        for (const particle of this.particles) {
          particle.draw(this.ctx);
        }

        // Reset shadow
        this.ctx.shadowBlur = 0;
      },

      // Update stats display
      updateStats() {
        document.getElementById('fpsValue').textContent = this.fps;
        document.getElementById('totalParticles').textContent = this.particles.length;
        document.getElementById('currentVariety').textContent = params.variety;
      },

      // Reset simulation
      reset() {
        this.pause();
        this.createParticles();
        this.draw();
      },

      // Pause simulation
      pause() {
        this.isPaused = true;
      },

      // Resume simulation
      play() {
        this.isPaused = false;
        this.lastTime = performance.now();
      }
    };

    // UI Controller
    const UIController = {
      sidebar: null,
      overlay: null,
      playButton: null,
      resetButton: null,

      init() {
        this.sidebar = document.getElementById('simulationSidebar');
        this.overlay = document.getElementById('simulationOverlay');
        this.playButton = document.getElementById('playButton');
        this.resetButton = document.getElementById('resetButton');

        this.setupSidebarToggle();
        this.setupControls();
        this.setupOverlay();
        this.setupCanvas();
        this.showOverlay();
      },

      setupSidebarToggle() {
          const toggle = document.getElementById('sidebarToggle');
          toggle.addEventListener('click', () => {
          this.sidebar.classList.toggle('collapsed');
          toggle.textContent = this.sidebar.classList.contains('collapsed') ? '☰' : '✕';
          });
          },

      setupControls() {
        // Variety
        const varietyInput = document.getElementById('variety');
        const varietyValue = document.getElementById('varietyValue');
        varietyInput.addEventListener('input', (e) => {
          params.variety = parseInt(e.target.value);
          varietyValue.textContent = params.variety;
          this.updateParticleTypeVisibility();
        });

        // Particle Count A
        const countAInput = document.getElementById('particleCountA');
        const countAValue = document.getElementById('particleCountAValue');
        countAInput.addEventListener('input', (e) => {
          params.particleCountA = parseInt(e.target.value);
          countAValue.textContent = params.particleCountA;
        });

        // Particle Count B
        const countBInput = document.getElementById('particleCountB');
        const countBValue = document.getElementById('particleCountBValue');
        countBInput.addEventListener('input', (e) => {
          params.particleCountB = parseInt(e.target.value);
          countBValue.textContent = params.particleCountB;
        });

        // Particle Count C
        const countCInput = document.getElementById('particleCountC');
        const countCValue = document.getElementById('particleCountCValue');
        countCInput.addEventListener('input', (e) => {
          params.particleCountC = parseInt(e.target.value);
          countCValue.textContent = params.particleCountC;
        });

        // Particle Count D
        const countDInput = document.getElementById('particleCountD');
        const countDValue = document.getElementById('particleCountDValue');
        countDInput.addEventListener('input', (e) => {
          params.particleCountD = parseInt(e.target.value);
          countDValue.textContent = params.particleCountD;
        });

        // Particle Count E
        const countEInput = document.getElementById('particleCountE');
        const countEValue = document.getElementById('particleCountEValue');
        countEInput.addEventListener('input', (e) => {
          params.particleCountE = parseInt(e.target.value);
          countEValue.textContent = params.particleCountE;
        });

        // Temperature
        const temperatureInput = document.getElementById('temperature');
        const temperatureValue = document.getElementById('temperatureValue');
        temperatureInput.addEventListener('input', (e) => {
          params.temperature = parseFloat(e.target.value);
          temperatureValue.textContent = params.temperature.toFixed(1);
        });

        // Initial visibility update
        this.updateParticleTypeVisibility();
      },

      updateParticleTypeVisibility() {
        const typeControls = [
          document.getElementById('particleCountC').parentElement,
          document.getElementById('particleCountD').parentElement,
          document.getElementById('particleCountE').parentElement
        ];

        typeControls.forEach((control, index) => {
          if (index + 3 <= params.variety) {
            control.style.display = 'block';
          } else {
            control.style.display = 'none';
          }
        });
      },

      setupOverlay() {
        this.playButton.addEventListener('click', () => {
          Simulation.play();
          this.hideOverlay();
        });

        this.resetButton.addEventListener('click', () => {
          Simulation.reset();
          this.showOverlay();
        });
      },

      setupCanvas() {
        const canvas = document.getElementById('simulationCanvas');
        canvas.addEventListener('click', () => {
          Simulation.pause();
          this.showOverlay();
        });
      },

      showOverlay() {
        this.overlay.classList.add('active');
      },

      hideOverlay() {
        this.overlay.classList.remove('active');
      }
    };

    // Initialize everything on page load
    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('simulationCanvas');
      Simulation.init(canvas, params);
      UIController.init();
    });
  </script>

  <script src="../../assets/js/main.js"></script>
</body>
</html>